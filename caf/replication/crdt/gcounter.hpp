/******************************************************************************
 *                       ____    _    _____                                   *
 *                      / ___|  / \  |  ___|    C++                           *
 *                     | |     / _ \ | |_       Actor                         *
 *                     | |___ / ___ \|  _|      Framework                     *
 *                      \____/_/   \_|_|                                      *
 *                                                                            *
 * Copyright (C) 2011 - 2016                                                  *
 * Dominik Charousset <dominik.charousset (at) haw-hamburg.de>                *
 * Marian Triebe <marian.triebe (at) haw-hamburg.de>                          *
 *                                                                            *
 * Distributed under the terms and conditions of the BSD 3-Clause License or  *
 * (at your option) under the terms and conditions of the Boost Software      *
 * License 1.0. See accompanying files LICENSE and LICENSE_ALTERNATIVE.       *
 *                                                                            *
 * If you did not receive a copy of the license files, see                    *
 * http://opensource.org/licenses/BSD-3-Clause and                            *
 * http://www.boost.org/LICENSE_1_0.txt.                                      *
 ******************************************************************************/

#ifndef CAF_REPLICATION_CRDT_GCOUNTER_HPP
#define CAF_REPLICATION_CRDT_GCOUNTER_HPP

#include <tuple>
#include <vector>
#include <unordered_map>

#include "caf/node_id.hpp"

#include "caf/replication/crdt/base_datatype.hpp"
#include "caf/replication/crdt/base_transaction.hpp"

// TODO: Add unit test for this type!

namespace caf {
namespace replication {
namespace crdt {

namespace {

/// A gset support the following mutable operations
enum class gcounter_operations {
  none,
  increment_by,
};

/// Describes a transation for gcounter<> as CmRDT
template <class T>
struct gcounter_transaction : public base_transaction {
  using operation_t = gcounter_operations;
  /// Buffered operations
  using buffer_entry_t = std::tuple<node_id, operation_t, T>;
  using buffer_t = std::vector<buffer_entry_t>;

  gcounter_transaction() = default;

  virtual ~gcounter_transaction() = default;

  /// Generated by local changes
  gcounter_transaction(std::string topic, actor owner, operation_t op, T value)
      : base_transaction(std::move(topic), std::move(owner)),
        buffer_{std::make_tuple(node_id{}, op, value)} {
    // nop
  }

  /// Construct a new transaction
  gcounter_transaction(std::string topic, actor owner)
    : base_transaction(std::move(topic), std::move(owner)) {
    // nop
  }

  /// Put a new transaction in current buffer
  inline void put(const node_id& nid, const operation_t& op, T value) {
    buffer_.emplace_back(nid, op, value);
  }

  /// Returns the operation of this transaction
  inline const buffer_t& operations() const { return buffer_; }

  /// Clear the internal buffer
  inline void clear() { buffer_.clear(); }

  template <class Processor>
  friend void serialize(Processor& proc, gcounter_transaction<T>& x) {
    proc & x.buffer_;
  }

private:
  buffer_t buffer_;
};

namespace delta {

/// This state is hold by top level replica, the CRDT is implementet as
/// delta-CRDT.
/// @private
template <class T>
struct gcounter_impl {
  using operator_t = gcounter_operations;
  using transaction_t = gcounter_transaction<T>;

  /// Default constructor
  gcounter_impl() = default;

  gcounter_impl(std::unordered_map<node_id, T> map) : map_(std::move(map)) {
    // nop
  }

  /// Apply transaction from a local subscriber to top level replica
  /// @param history a transaction
  /// @return a delta-CRDT which represent the delta
  gcounter_impl<T> apply(const transaction_t& history) {
    std::unordered_map<node_id, T> delta;
    for (auto& t : history.operations())
      if (std::get<1>(t) == operator_t::increment_by) {
        map_[std::get<0>(t)] += std::get<2>(t);
        delta[std::get<0>(t)] = map_[std::get<0>(t)];
      }
    return {std::move(delta)};
  }

  /// Merge function, for this type it is simple
  /// @param topic of this replica
  /// @param other delta-CRDT to merge into this
  /// @returns a delta gset<T>
  gcounter_impl<T> merge(const std::string&, const gcounter_impl<T>& other) {
    std::unordered_map<node_id, T> delta;
    for (auto& tup : other.map_) {
      auto key = tup.first;
      if (map_[key] < tup.second) {
        // Generate transaction
        auto diff = tup.second - map_[key];
        // Overwrite old value
        map_[key] = tup.second;
        // Store in delta
        delta.emplace(key, tup.second);
        // Add to CmRDT buffer
        buffered_.put(key, operator_t::increment_by, diff);
      }
    }
    return {std::move(delta)};
  }

  /// Unite this and a delta State, this is usefull if `this` also represent
  /// a delta State
  void unite(const gcounter_impl<T>& delta) {
    // Simply merge both types TODO: Is this correct?
    merge(delta);
  }

  /// This is used to convert this delta-CRDT to CmRDT transactions
  /// @param topic for this transaction
  transaction_t get_cmrdt_transactions(const std::string&, const actor&) {
    auto cpy = buffered_;
    buffered_.clear();
    return cpy;
  }

  /// @returns `true` if the state is empty
  ///          `false` otherwise
  inline bool empty() const { return map_.empty(); }

  /// Clear the internal set
  inline void clear() { map_.clear(); }

  /// @private
  template <class Processor>
  friend void serialize(Processor& proc, gcounter_impl<T>& x) {
    proc & x.buffered_;
    proc & x.map_;
  }

private:
  transaction_t buffered_; /// Here we buffer transactions, we discovered
                           /// by merge
  std::unordered_map<node_id, T> map_; /// Map nodes to values
};

} // namespace delta

namespace cmrdt {

/// Grow only counter as CmRDT.
template <class T>
class gcounter_impl : public base_datatype {
public:
  using operator_t = gcounter_operations;
  /// Mutable operations will trigger this type
  using transaction_t = gcounter_transaction<T>;

  gcounter_impl() : value_{0} {
    // nop
  }

  // --- Delete forbidden operators
  T& operator=(const T&) = delete;
  T operator-=(const T&) = delete;
  T& operator--() = delete;
  T operator--(T) = delete;

  // --- Allowed operators

  /// Increment by operator
  /// @param by number to increment by
  /// @return the new value
  T operator+=(const T& by) {
    if (by > 0) {
      value_ += by;
      publish(transaction_t{topic(), owner(), operator_t::increment_by, by});
    }
    return value_;
  }

  /// Pre-Increment operator
  /// @return increment and return new value
  T& operator++() {
    value_ += 1;
    publish(transaction_t{topic(), owner(), operator_t::increment_by, 1});
    return value_;
  }

  /// Post-Increment operator
  /// @return increment and return old value
  T operator++(T) {
    auto cpy = value_;
    operator++();
    return cpy;
  }

  /// @return the current value of gcounter<T>
  T count() const { return value_; }

  /// Apply transaction to local CmRDT type
  /// @param history to apply
  void apply(const transaction_t& history) {
    for (auto& t : history.operations())
    if (std::get<1>(t) == operator_t::increment_by)
      value_ += std::get<2>(t);
  }

  /// @private
  template <class Processor>
  friend void serialize(Processor& proc, gcounter_impl<T>& x) {
    proc & x.value_;
  }

private:
  T value_; /// Numeric value
};

} // namespace cmrdt

} // namespace <anonymous>

/// Implementation of a grow-only counter (GCounter)
template <class T>
struct gcounter : public cmrdt::gcounter_impl<T> {
  /// Internal type of gcounter, this implementation is used between
  using internal_t = delta::gcounter_impl<T>;
  /// Internal used for hierarchical propagation
  using transaction_t = typename cmrdt::gcounter_impl<T>::transaction_t;
};

} // namespace crdt
} // namespace replication
} // namespace caf

#endif // CAF_REPLICATION_CRDT_GCOUNTER_HPP
